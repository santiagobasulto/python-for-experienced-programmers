{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python for experienced programmers \u00b6 I consider myself an experienced developer (I've been coding for more than 10 years). This book is what I'd like to read if I was interested in learning Python today. The problem with most books is that they're geared towards beginners: they rarely focus on Python (its dev environment, its best practices, shortcomings, etc). They teach people how to code using Python , which is a completely different deal. In this book, I assume you know how to code, you know different paradigms, and more importantly, you know how to Google. You're a capable developer trying to get up to speed with Python, this should be as concise as possible. This book is not linear. Another big weakness of programming books is that they focus just on the language , when we all know that being proficient with a language is more than learning the syntax. Did you know that additions and improvements to the Python language are discussed in PEPs (Python Enhancement Proposal) and you can submit your own? Did you know that the main Python conference around the world is PyCon and there's one in practically every country? Did you know that the name \"Python\" is derived from Monty Python , the british comedy group? A programming language isn't just a tool, it's a whole ecosystem, is a social activity, it's a way of thinking, it's a philosophy, it's even politics. Most books will tell you \"download Python and start\". Well, that's not how experienced Python developers work: we create virtualenvs, we use package locking tools like Poetry, we use pyenv to manaage multiple Python versions (oh yeah, there are multiple versions of Python and it's a big deal). Actually, \"downloading Python\" could even be considered an anti-pattern. I think I've NEVER just \"downloaded Python\". I hope you enjoy this book and you keep it as a reference. My goal is to make it as concise as possible, cutting the BS and just giving you the facts straight so you can get up to speed with Python in the minimum amount of time.","title":"1. Introduction"},{"location":"#python-for-experienced-programmers","text":"I consider myself an experienced developer (I've been coding for more than 10 years). This book is what I'd like to read if I was interested in learning Python today. The problem with most books is that they're geared towards beginners: they rarely focus on Python (its dev environment, its best practices, shortcomings, etc). They teach people how to code using Python , which is a completely different deal. In this book, I assume you know how to code, you know different paradigms, and more importantly, you know how to Google. You're a capable developer trying to get up to speed with Python, this should be as concise as possible. This book is not linear. Another big weakness of programming books is that they focus just on the language , when we all know that being proficient with a language is more than learning the syntax. Did you know that additions and improvements to the Python language are discussed in PEPs (Python Enhancement Proposal) and you can submit your own? Did you know that the main Python conference around the world is PyCon and there's one in practically every country? Did you know that the name \"Python\" is derived from Monty Python , the british comedy group? A programming language isn't just a tool, it's a whole ecosystem, is a social activity, it's a way of thinking, it's a philosophy, it's even politics. Most books will tell you \"download Python and start\". Well, that's not how experienced Python developers work: we create virtualenvs, we use package locking tools like Poetry, we use pyenv to manaage multiple Python versions (oh yeah, there are multiple versions of Python and it's a big deal). Actually, \"downloading Python\" could even be considered an anti-pattern. I think I've NEVER just \"downloaded Python\". I hope you enjoy this book and you keep it as a reference. My goal is to make it as concise as possible, cutting the BS and just giving you the facts straight so you can get up to speed with Python in the minimum amount of time.","title":"Python for experienced programmers"},{"location":"basics/","text":"Language Basics \u00b6 Python is a very intuitive language. Let's do a quick summary of all the basics to get you started. Indentation \u00b6 Python uses indentation to define blocks, and each \"level\" of indentation is separated by the colon sing ( : ). An example explains it better: for user in users : if user . is_active : try : send_email ( user ) except EmailException : logging . error ( \"An error occurred\" ) else : logging . debug ( \"Skipping, inactive user\" ) There's an amusing easter egg built into the language involving braces: >>> from __future__ import braces File \"<stdin>\" , line 1 SyntaxError : not a chance Each statement in Python is determined with a new line, as you can see from the example above. Optionally, you can use a semicolon ( ; ) to separate multiple statements in the same line, but this is rarely used: >>> import random ; random . randint ( 0 , 99 ) 30 Tabs vs spaces: code formatting \u00b6 Do NOT use tabs. Use 4 spaces for indentation level. It's recommended by PEP 8 and it's a standard in the industry. Make sure you set your editor with the right configuration. Comments \u00b6 Python has only one type of comment, a single-line comment. To create a comment, preface the line with the pound character ( # ). Example: # This is a comment # This too print ( \"This # is not#\" ) Comments are stripped out in the process of interpretation (when the interpreter compiles the source into bytecode) so it's totally safe to add as many comments as you want (sorry, you can't use \"size\" as an excuse not to comment your code). There are no multi-line comments in Python. There's a hack though, an alternative \"solution\", which involves using multiline strings (a pair of triple quotes \"\"\" or ''' ): \"\"\" This code has no effect 1/0 doesn't break for example \"\"\" But again, these are not actual comments and they'll be evaluated by your Python interpreter. They might have unintended consequences in some situations (like in function docs) and they just don't look like comments. Your editor should include a simple way to comment/uncomment pieces of code using the pound char # . Warning Try to avoid multi-line strings as comments. Instead, put some time in configuring your editor to comment out block of codes using a simple key combination, like cmd + / . Python program evaluation \u00b6 Python parses a program from top to bottom, and processes definitions as it finds them. This might have some unintended consequences. For example, the following code will raise an exception: say_hello () def say_hello (): print ( \"Hello world\" ) The exception is a NameError , as we're trying to invoke a function say_hello and it doesn't exit (yet). It will start existing once the function block is evaluated. Variables and names \u00b6 Variables are set by just assigning them to a value, there's no need to \"declare\" them. Assignment is performed with the equals sign ( = ). x = 2 name = \"String\" email = 'hello@example.com' Note There's no difference between single and double quoted strings. See the chapter about strings for more. Variable names don't have a length restriction. Valid characters are uppercase and lowercase letters ( A-Z , a-z ), digits ( 0-9 ), and the underscore character ( _ ). Although digits can't be at the start of the variable name: 99name is invalid and _99name is valid. You can delete a variable using the del keyword, but this doesn't mean the underlying value is deleted and the memory is free. Remember Python's Garbage Collector and reference counting: >>> class Car : >>> pass >>> x = Car () >>> x < __main__ . Car object at 0x10fc52850 > >>> y = x >>> y < __main__ . Car object at 0x10fc52850 > >>> del x >>> y < __main__ . Car object at 0x10fc52850 > >>> x Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > NameError : name 'x' is not defined Variable Unpacking \u00b6 Whenever you Object identity \u00b6 In our previous example you'll see a hex number associated with the Car object. In Python, each object created has a unique identifier that you can check with the id function: >>> x = 1 >>> id ( x ) 4363573440 >>> id ( \"Hello World\" ) 4368164144 By checking IDs you'll find out that some objects in python are \"interned\", or cached for simplicity. This is evident for integers: >>> x = 1 >>> y = 1 >>> z = 4 - 3 >>> id ( x ) 4363573440 >>> id ( y ) 4363573440 >>> id ( z ) 4363573440 This means that there's only 1 instance of the object 1 created and it's always reused. It happens the same thing for strings: >>> s1 = \"hello\" >>> s2 = \"hello\" >>> id ( s1 ) 4368226800 >>> id ( s2 ) 4368226800 >>> id ( \"hello\" ) 4368226800 But you should be careful with object interning, because it's interpreter dependant (I have tried this only in CPython 3.8) and it's just done for a handful of objects. For example, for integers, it only applies for integers between -5 and 256 . From the C-API docs : The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-) In the following example you see that even though both objects represent the same number, they're actually to difference instances: >>> x = 257 >>> y = 257 >>> id ( x ) 4537070032 >>> id ( y ) 4537070064 The is operator \u00b6 We have an entire chapter discussing operators, but it's important to discuss the is operator early, as it is a usual source of confusion. The is operator, applied in the form obj1 is obj2 , checks if obj1 and obj2 are the same object . It's equivalent to id(obj1) == id(obj2) . Which, given the previously discussed \"implementation specific\" behavior of object interning, might throw \"unexpected\" results: >>> x = 1 >>> y = 1 >>> x is y True # The following line might result surprising for new Pythoners: >>> x = 257 >>> y = 257 >>> x is y False In reality, this is completely expected behavior. The correct operator to use to check equality is == . As a rule of thumb, try to avoid the is operator. There could be an exception for explicit boolean checks ( x is True ), but that'd mean that you want to check that x is literally True , when in reality the desire is to check if x is truthy . More about all of this in the Data Types and Operators chapters. Python Bytecode \u00b6 Similarly to Java, Python will transform your source code into bytecode (an intermediary step) before actually running it. The process of running python main.py is roughly: The interpreter will load the main.py script and generate the intermediate bytecode The Python runtime (also called virtual machine) will now run the generated bytecode . There are two main advantages of the bytecode format. First, Python can optimize the bytecode without requiring you to make changes to your scripts (see the peephole optimizer ). Secondly, the bytecode generated can be cached as long as modules are not modified. Python stores cached bytecode in files with the extension *.pyc . Starting with Python 3.2 (see PEP 3147 ), all bytecode cached files are located in a special directory __pycache__ . Back when we were using Python 2, these files would be at the same location as the actual Python module and it was very annoying. If you don't want Python to generate these cached bytecode files, pass the -B flag to the interpreter or set the PYTHONDONTWRITEBYTECODE to anything, although this is not recommended (caching is good). The dis module includes functions for working with Python bytecode by disassembling it into a more human-readable form. For example, let's disassemble the statement x += 1 : x = 0 x += 1 If you put that in a module ( my_dis_module.py ) and run dis from the command line python -m dis my_dis_module.py , we'll get: 1 0 LOAD_CONST 0 ( 0 ) 2 STORE_NAME 0 ( x ) 2 4 LOAD_NAME 0 ( x ) 6 LOAD_CONST 1 ( 1 ) 8 INPLACE_ADD 10 STORE_NAME 0 ( x ) 12 LOAD_CONST 2 ( None ) 14 RETURN_VALUE In the first chunk corresponds to x = 0 . The CPython interpreter is stack based, which means that the values/constants are allocated first. It follows then by referencing the variable x to that previously stored value. The second chunk shows the operation INPLACE_ADD , which is the bytecode operation generated by the += operator.","title":"3. Language Basics"},{"location":"basics/#language-basics","text":"Python is a very intuitive language. Let's do a quick summary of all the basics to get you started.","title":"Language Basics"},{"location":"basics/#indentation","text":"Python uses indentation to define blocks, and each \"level\" of indentation is separated by the colon sing ( : ). An example explains it better: for user in users : if user . is_active : try : send_email ( user ) except EmailException : logging . error ( \"An error occurred\" ) else : logging . debug ( \"Skipping, inactive user\" ) There's an amusing easter egg built into the language involving braces: >>> from __future__ import braces File \"<stdin>\" , line 1 SyntaxError : not a chance Each statement in Python is determined with a new line, as you can see from the example above. Optionally, you can use a semicolon ( ; ) to separate multiple statements in the same line, but this is rarely used: >>> import random ; random . randint ( 0 , 99 ) 30","title":"Indentation"},{"location":"basics/#tabs-vs-spaces-code-formatting","text":"Do NOT use tabs. Use 4 spaces for indentation level. It's recommended by PEP 8 and it's a standard in the industry. Make sure you set your editor with the right configuration.","title":"Tabs vs spaces: code formatting"},{"location":"basics/#comments","text":"Python has only one type of comment, a single-line comment. To create a comment, preface the line with the pound character ( # ). Example: # This is a comment # This too print ( \"This # is not#\" ) Comments are stripped out in the process of interpretation (when the interpreter compiles the source into bytecode) so it's totally safe to add as many comments as you want (sorry, you can't use \"size\" as an excuse not to comment your code). There are no multi-line comments in Python. There's a hack though, an alternative \"solution\", which involves using multiline strings (a pair of triple quotes \"\"\" or ''' ): \"\"\" This code has no effect 1/0 doesn't break for example \"\"\" But again, these are not actual comments and they'll be evaluated by your Python interpreter. They might have unintended consequences in some situations (like in function docs) and they just don't look like comments. Your editor should include a simple way to comment/uncomment pieces of code using the pound char # . Warning Try to avoid multi-line strings as comments. Instead, put some time in configuring your editor to comment out block of codes using a simple key combination, like cmd + / .","title":"Comments"},{"location":"basics/#python-program-evaluation","text":"Python parses a program from top to bottom, and processes definitions as it finds them. This might have some unintended consequences. For example, the following code will raise an exception: say_hello () def say_hello (): print ( \"Hello world\" ) The exception is a NameError , as we're trying to invoke a function say_hello and it doesn't exit (yet). It will start existing once the function block is evaluated.","title":"Python program evaluation"},{"location":"basics/#variables-and-names","text":"Variables are set by just assigning them to a value, there's no need to \"declare\" them. Assignment is performed with the equals sign ( = ). x = 2 name = \"String\" email = 'hello@example.com' Note There's no difference between single and double quoted strings. See the chapter about strings for more. Variable names don't have a length restriction. Valid characters are uppercase and lowercase letters ( A-Z , a-z ), digits ( 0-9 ), and the underscore character ( _ ). Although digits can't be at the start of the variable name: 99name is invalid and _99name is valid. You can delete a variable using the del keyword, but this doesn't mean the underlying value is deleted and the memory is free. Remember Python's Garbage Collector and reference counting: >>> class Car : >>> pass >>> x = Car () >>> x < __main__ . Car object at 0x10fc52850 > >>> y = x >>> y < __main__ . Car object at 0x10fc52850 > >>> del x >>> y < __main__ . Car object at 0x10fc52850 > >>> x Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > NameError : name 'x' is not defined","title":"Variables and names"},{"location":"basics/#variable-unpacking","text":"Whenever you","title":"Variable Unpacking"},{"location":"basics/#object-identity","text":"In our previous example you'll see a hex number associated with the Car object. In Python, each object created has a unique identifier that you can check with the id function: >>> x = 1 >>> id ( x ) 4363573440 >>> id ( \"Hello World\" ) 4368164144 By checking IDs you'll find out that some objects in python are \"interned\", or cached for simplicity. This is evident for integers: >>> x = 1 >>> y = 1 >>> z = 4 - 3 >>> id ( x ) 4363573440 >>> id ( y ) 4363573440 >>> id ( z ) 4363573440 This means that there's only 1 instance of the object 1 created and it's always reused. It happens the same thing for strings: >>> s1 = \"hello\" >>> s2 = \"hello\" >>> id ( s1 ) 4368226800 >>> id ( s2 ) 4368226800 >>> id ( \"hello\" ) 4368226800 But you should be careful with object interning, because it's interpreter dependant (I have tried this only in CPython 3.8) and it's just done for a handful of objects. For example, for integers, it only applies for integers between -5 and 256 . From the C-API docs : The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-) In the following example you see that even though both objects represent the same number, they're actually to difference instances: >>> x = 257 >>> y = 257 >>> id ( x ) 4537070032 >>> id ( y ) 4537070064","title":"Object identity"},{"location":"basics/#the-is-operator","text":"We have an entire chapter discussing operators, but it's important to discuss the is operator early, as it is a usual source of confusion. The is operator, applied in the form obj1 is obj2 , checks if obj1 and obj2 are the same object . It's equivalent to id(obj1) == id(obj2) . Which, given the previously discussed \"implementation specific\" behavior of object interning, might throw \"unexpected\" results: >>> x = 1 >>> y = 1 >>> x is y True # The following line might result surprising for new Pythoners: >>> x = 257 >>> y = 257 >>> x is y False In reality, this is completely expected behavior. The correct operator to use to check equality is == . As a rule of thumb, try to avoid the is operator. There could be an exception for explicit boolean checks ( x is True ), but that'd mean that you want to check that x is literally True , when in reality the desire is to check if x is truthy . More about all of this in the Data Types and Operators chapters.","title":"The is operator"},{"location":"basics/#python-bytecode","text":"Similarly to Java, Python will transform your source code into bytecode (an intermediary step) before actually running it. The process of running python main.py is roughly: The interpreter will load the main.py script and generate the intermediate bytecode The Python runtime (also called virtual machine) will now run the generated bytecode . There are two main advantages of the bytecode format. First, Python can optimize the bytecode without requiring you to make changes to your scripts (see the peephole optimizer ). Secondly, the bytecode generated can be cached as long as modules are not modified. Python stores cached bytecode in files with the extension *.pyc . Starting with Python 3.2 (see PEP 3147 ), all bytecode cached files are located in a special directory __pycache__ . Back when we were using Python 2, these files would be at the same location as the actual Python module and it was very annoying. If you don't want Python to generate these cached bytecode files, pass the -B flag to the interpreter or set the PYTHONDONTWRITEBYTECODE to anything, although this is not recommended (caching is good). The dis module includes functions for working with Python bytecode by disassembling it into a more human-readable form. For example, let's disassemble the statement x += 1 : x = 0 x += 1 If you put that in a module ( my_dis_module.py ) and run dis from the command line python -m dis my_dis_module.py , we'll get: 1 0 LOAD_CONST 0 ( 0 ) 2 STORE_NAME 0 ( x ) 2 4 LOAD_NAME 0 ( x ) 6 LOAD_CONST 1 ( 1 ) 8 INPLACE_ADD 10 STORE_NAME 0 ( x ) 12 LOAD_CONST 2 ( None ) 14 RETURN_VALUE In the first chunk corresponds to x = 0 . The CPython interpreter is stack based, which means that the values/constants are allocated first. It follows then by referencing the variable x to that previously stored value. The second chunk shows the operation INPLACE_ADD , which is the bytecode operation generated by the += operator.","title":"Python Bytecode"},{"location":"control_flow/","text":"Control flow \u00b6 Python won't give you any unpleasant surprises when it comes to Control Flow. On the contrary, you might find a few interesting features that are not part of other traditional dynamic languages. Personally, the feature that I miss the most in Python is the lack of \"expression oriented control flow\", as you can find in Scala or F#. Indentation \u00b6 Indentation, as seen before, is what defines the current \"active block\". Although, as we'll see later in this same chapter, Python control flow structures don't define new \"execution frames\" or namespaces, differently from other languages as Java or C, for example. # Not valid Python code, just a demonstration of indentation if [ condition ]: for [ elem in elements ]: if [ another condition ]: # inside another condition else : # inside ELSE of another condition else : # Inside else of main if If statements \u00b6 An example: age = int ( input ( 'Enter your age: ' )) if x > 21 : print ( \"You can drive and drink\" ) elif x > 18 : print ( \"You can only drive\" ) else : print ( \"Sorry. You'll have to wait for all the fun stuff\" ) You can see the use of the elif clause, which is just else if . Python does NOT have a switch statement , so the elif clause replaces part of that behavior. Ternary operator \u00b6 The ternary operator is not so commonly used, as it might hurt readability, but it's still useful to know it: x = int ( input ( \"Enter a number: \" )) even_or_odd = \"even\" if ( x % 2 == 0 ) else \"odd\" A more \"Pythonic\" approach would use an explicit if statement: x = int ( input ( \"Enter a number: \" )) if x % 2 == 0 : even_or_odd = \"even\" else : even_or_odd = \"odd\" The ternary operator can be chained for even less readable operations, so please try to avoid it: def teenager_test ( age ): return ( \"drive and drink\" if age >= 21 else \"only drive\" if age >= 18 else \"Nothing fun\" ) Truthy, Falsy \u00b6 Python's decision to go through an if or else branch is based on the value of the expression passed. In the boolean operators section we'll discuss in further detail the concepts of truthy/falsy values. For now, what you need to know is that we prefer pythonic expressions that are oriented to truthy/falsy statements, instead of booleans. For example, the following statement is NOT considered Pythonic, as it tries to \"force\" a boolean: if user . email_verified is True : # body In this case, user.email_verified must return a boolean value. It can't return anything else (the datetime of the verification, for example). A more Pythonic approach is just: if user . email_verified : # body The same for collections. A non pythonic approach is: if len ( a_list ) > 0 : Empty collections are falsy. So we can just rewrite it in this way: if a_list : Tip Remember the issue with the is operator. Try to avoid it as much as possible, and only use it whenever you want to explicitly check the same object. For loops \u00b6 For loops in Python are NOT like for loops in other languages. They're what, in other languages, are called \"for each\" loops. They let you step over elements from an iterator. Example: fruits = [ 'Apple' , 'Orange' , 'Banana' ] for fruit in fruits : print ( fruit ) A traditional for loop in another language looks something like: for(initialization; condition; step) , as the following example: // Javascript for ( i = 0 ; i < 5 ; i ++ ){ console . log ( i ) } There's not such thing in Python. To recreate the previous example, we need an iterator containing the elements first: elements = [ 0 , 1 , 2 , 3 , 4 ] for elem in elements : print ( elem ) This is obviously not practical, and that's why it's so simple (and crucial to Python) to use iterators and generators. For this particular example, we can use the range function: # prints 0 to 4 for elem in range ( 5 ): print ( elem ) The range function accepts 3 parameters, (init, end, step) : >>> list ( range ( 2 , 10 )) [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> list ( range ( 2 , 10 , 2 )) [ 2 , 4 , 6 , 8 ] >>> list ( range ( 10 , 0 , - 1 )) [ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ] Variable Scope \u00b6 The first thing you'll notice is that control flow structures don't create namespaces or blocks: >>> for i in range ( 5 ): >>> pass >>> i 4 The i variable is bound and keeps the value of the last iteration. The same happens for variables defined \"inside\" the block: >>> for _ in range ( 5 ): >>> a = 9 >>> a 9 Again, this indicates that Python control flow blocks, don't create new execution frames or namespaces . If you come from a language that actually creates new execution frames, be careful not to clutter the namespace with variables generated inside the control flow blocks. This might also result in some unpleasant surprises, like in this example inspired by an interesting discussion in Python's email list : >>> lst = [] >>> for i in range ( 3 ): >>> lst . append ( lambda : i ) >>> [ f () for f in lst ] [ 2 , 2 , 2 ] List Comprehensions \u00b6 The last statement of our previous example is a list comprehension: [f() for f in lst] . There's more about list comprehensions in the Functional programming chapter, but at a glance, this is what you need to know: A list comprehension works with any iterable, not just lists (should we call it iterator comprehension ?). It has the following form [(expression) for (element) in (iterable)] . Optionally, it can be passed a \"filtering\" expression at the end. The final result then is: [(expression) for (element) in (iterable) if (condition)] . Examples will speak by themselves: >>> [ x ** 2 for x in range ( 5 )] [ 0 , 1 , 4 , 9 , 16 ] >>> [ x ** 2 for x in range ( 5 ) if x > 2 ] [ 9 , 16 ] >>> [( x , x ** 2 ) for x in range ( 5 ) if x > 2 ] [( 3 , 9 ), ( 4 , 16 )] Our previous example involving weird scoping of variables can be rewritten using comprehensions in the following way: >>> lst = [ lambda : i for i in range ( 4 )] >>> [ f () for f in lst ] [ 3 , 3 , 3 , 3 ] Comprehensions are good Always prefer list comprehensions over for loops when possible. List comprehensions are expressive and declarative, compared to for loops which are imperative. break and continue \u00b6 The break clause will immediately break the current for loop: user_to_find = 'mary@example.com' for user in users : if user == users_to_find : print ( \"User found!\" ) break Enumerate Unpacking Summary \u00b6 No switch/case.","title":"4. Control Flow"},{"location":"control_flow/#control-flow","text":"Python won't give you any unpleasant surprises when it comes to Control Flow. On the contrary, you might find a few interesting features that are not part of other traditional dynamic languages. Personally, the feature that I miss the most in Python is the lack of \"expression oriented control flow\", as you can find in Scala or F#.","title":"Control flow"},{"location":"control_flow/#indentation","text":"Indentation, as seen before, is what defines the current \"active block\". Although, as we'll see later in this same chapter, Python control flow structures don't define new \"execution frames\" or namespaces, differently from other languages as Java or C, for example. # Not valid Python code, just a demonstration of indentation if [ condition ]: for [ elem in elements ]: if [ another condition ]: # inside another condition else : # inside ELSE of another condition else : # Inside else of main if","title":"Indentation"},{"location":"control_flow/#if-statements","text":"An example: age = int ( input ( 'Enter your age: ' )) if x > 21 : print ( \"You can drive and drink\" ) elif x > 18 : print ( \"You can only drive\" ) else : print ( \"Sorry. You'll have to wait for all the fun stuff\" ) You can see the use of the elif clause, which is just else if . Python does NOT have a switch statement , so the elif clause replaces part of that behavior.","title":"If statements"},{"location":"control_flow/#ternary-operator","text":"The ternary operator is not so commonly used, as it might hurt readability, but it's still useful to know it: x = int ( input ( \"Enter a number: \" )) even_or_odd = \"even\" if ( x % 2 == 0 ) else \"odd\" A more \"Pythonic\" approach would use an explicit if statement: x = int ( input ( \"Enter a number: \" )) if x % 2 == 0 : even_or_odd = \"even\" else : even_or_odd = \"odd\" The ternary operator can be chained for even less readable operations, so please try to avoid it: def teenager_test ( age ): return ( \"drive and drink\" if age >= 21 else \"only drive\" if age >= 18 else \"Nothing fun\" )","title":"Ternary operator"},{"location":"control_flow/#truthy-falsy","text":"Python's decision to go through an if or else branch is based on the value of the expression passed. In the boolean operators section we'll discuss in further detail the concepts of truthy/falsy values. For now, what you need to know is that we prefer pythonic expressions that are oriented to truthy/falsy statements, instead of booleans. For example, the following statement is NOT considered Pythonic, as it tries to \"force\" a boolean: if user . email_verified is True : # body In this case, user.email_verified must return a boolean value. It can't return anything else (the datetime of the verification, for example). A more Pythonic approach is just: if user . email_verified : # body The same for collections. A non pythonic approach is: if len ( a_list ) > 0 : Empty collections are falsy. So we can just rewrite it in this way: if a_list : Tip Remember the issue with the is operator. Try to avoid it as much as possible, and only use it whenever you want to explicitly check the same object.","title":"Truthy, Falsy"},{"location":"control_flow/#for-loops","text":"For loops in Python are NOT like for loops in other languages. They're what, in other languages, are called \"for each\" loops. They let you step over elements from an iterator. Example: fruits = [ 'Apple' , 'Orange' , 'Banana' ] for fruit in fruits : print ( fruit ) A traditional for loop in another language looks something like: for(initialization; condition; step) , as the following example: // Javascript for ( i = 0 ; i < 5 ; i ++ ){ console . log ( i ) } There's not such thing in Python. To recreate the previous example, we need an iterator containing the elements first: elements = [ 0 , 1 , 2 , 3 , 4 ] for elem in elements : print ( elem ) This is obviously not practical, and that's why it's so simple (and crucial to Python) to use iterators and generators. For this particular example, we can use the range function: # prints 0 to 4 for elem in range ( 5 ): print ( elem ) The range function accepts 3 parameters, (init, end, step) : >>> list ( range ( 2 , 10 )) [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> list ( range ( 2 , 10 , 2 )) [ 2 , 4 , 6 , 8 ] >>> list ( range ( 10 , 0 , - 1 )) [ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ]","title":"For loops"},{"location":"control_flow/#variable-scope","text":"The first thing you'll notice is that control flow structures don't create namespaces or blocks: >>> for i in range ( 5 ): >>> pass >>> i 4 The i variable is bound and keeps the value of the last iteration. The same happens for variables defined \"inside\" the block: >>> for _ in range ( 5 ): >>> a = 9 >>> a 9 Again, this indicates that Python control flow blocks, don't create new execution frames or namespaces . If you come from a language that actually creates new execution frames, be careful not to clutter the namespace with variables generated inside the control flow blocks. This might also result in some unpleasant surprises, like in this example inspired by an interesting discussion in Python's email list : >>> lst = [] >>> for i in range ( 3 ): >>> lst . append ( lambda : i ) >>> [ f () for f in lst ] [ 2 , 2 , 2 ]","title":"Variable Scope"},{"location":"control_flow/#list-comprehensions","text":"The last statement of our previous example is a list comprehension: [f() for f in lst] . There's more about list comprehensions in the Functional programming chapter, but at a glance, this is what you need to know: A list comprehension works with any iterable, not just lists (should we call it iterator comprehension ?). It has the following form [(expression) for (element) in (iterable)] . Optionally, it can be passed a \"filtering\" expression at the end. The final result then is: [(expression) for (element) in (iterable) if (condition)] . Examples will speak by themselves: >>> [ x ** 2 for x in range ( 5 )] [ 0 , 1 , 4 , 9 , 16 ] >>> [ x ** 2 for x in range ( 5 ) if x > 2 ] [ 9 , 16 ] >>> [( x , x ** 2 ) for x in range ( 5 ) if x > 2 ] [( 3 , 9 ), ( 4 , 16 )] Our previous example involving weird scoping of variables can be rewritten using comprehensions in the following way: >>> lst = [ lambda : i for i in range ( 4 )] >>> [ f () for f in lst ] [ 3 , 3 , 3 , 3 ] Comprehensions are good Always prefer list comprehensions over for loops when possible. List comprehensions are expressive and declarative, compared to for loops which are imperative.","title":"List Comprehensions"},{"location":"control_flow/#break-and-continue","text":"The break clause will immediately break the current for loop: user_to_find = 'mary@example.com' for user in users : if user == users_to_find : print ( \"User found!\" ) break Enumerate Unpacking","title":"break and continue"},{"location":"control_flow/#summary","text":"No switch/case.","title":"Summary"},{"location":"data-types/","text":"Data Types \u00b6 Note Everything described in this chapter is based on Python 3. Python 2 had differences (specially with integers) that I'm not mentioning.","title":"5. Data Types"},{"location":"data-types/#data-types","text":"Note Everything described in this chapter is based on Python 3. Python 2 had differences (specially with integers) that I'm not mentioning.","title":"Data Types"},{"location":"magic_methods/","text":"Magic methods (or dunder methods , because of the \" double under scores\" they start and finish with) are special methods defined in a class that start and end with two underscores. Example: class MyList : def __len__ ( self ): pass In this example, __len__ is the magic method. Most experienced developers fail to understand magic methods because they treat them as a \"feature\" of the language (example: \"Magic methods are used for operator overloading\" ), when in reality, they're something a lot more profound: they're part of Python's Data Model . Think about it as a \"contract\" that you sign with Python's interpreter: a common interface for your classes. For example, you can be sure that the method __del__ will always be invoked before your object is garbage collected (to give you the chance to free resources, or clean things up). Sometimes, these methods do serve for operator overloading (the __add__ method overloads the + operator), but they might also be used by other library writers (like the __copy__ method, which is used by the copy module). There are a lot of magic methods and new PEPs introduce new ones (the Python Data Model keeps growing, and there are new protocols added). The best guide for most magic methods is this one: https://rszalski.github.io/magicmethods/ In this post I'll focus on the ones that you absolutely need to know . Life Cycle: object creation, initialization and destruction \u00b6 Magic methods discussed: __new__ __init__ __del__ We tend to call the __init__ method the \"constructor\" (specially people coming from a Java background, like myself). But in reality, it's an \"initializer\" method. Following this logic of \"the contract between you and Python\", you can be sure that after an object is created, Python will always invoke the __init__ method giving you a chance to initialize properties of your object. The \"real\" constructor equivalent method in Python is __new__ which is invoked with the class to create, but in reality it's rarely used. The __del__ method is invoked before Python garbage collects your object: its main use is to free up resources or do some clean up (closing files or database connections, for example). It's also rarely used. In the following example, we create a new connection when our object is initialized (the __init__ method) and we close it when it's finalized (the __del__ method). class ORM : def __init__ ( self , username , password , host ): self . conn = connect_db ( username , password , host ) def query ( self , q ): self . conn . execute ( q ) def __del__ ( self ): self . conn . close () Here's the full lifecyle of an object including magic methods: These magic methods are clear examples of methods that you never manually call, but they're invoked by Python at certain points of the execution of your program. Operator Overloading \u00b6 These methods are pretty self explanatory COMPARISON *","title":"6. Magic Methods"},{"location":"magic_methods/#life-cycle-object-creation-initialization-and-destruction","text":"Magic methods discussed: __new__ __init__ __del__ We tend to call the __init__ method the \"constructor\" (specially people coming from a Java background, like myself). But in reality, it's an \"initializer\" method. Following this logic of \"the contract between you and Python\", you can be sure that after an object is created, Python will always invoke the __init__ method giving you a chance to initialize properties of your object. The \"real\" constructor equivalent method in Python is __new__ which is invoked with the class to create, but in reality it's rarely used. The __del__ method is invoked before Python garbage collects your object: its main use is to free up resources or do some clean up (closing files or database connections, for example). It's also rarely used. In the following example, we create a new connection when our object is initialized (the __init__ method) and we close it when it's finalized (the __del__ method). class ORM : def __init__ ( self , username , password , host ): self . conn = connect_db ( username , password , host ) def query ( self , q ): self . conn . execute ( q ) def __del__ ( self ): self . conn . close () Here's the full lifecyle of an object including magic methods: These magic methods are clear examples of methods that you never manually call, but they're invoked by Python at certain points of the execution of your program.","title":"Life Cycle: object creation, initialization and destruction"},{"location":"magic_methods/#operator-overloading","text":"These methods are pretty self explanatory COMPARISON *","title":"Operator Overloading"},{"location":"meta/","text":"Python Language - Meta Guide \u00b6 Knowing a language is more than knowing how to write a for-loop or spawn a thread. A language has an associated community, governance and even a political view. The syntax of the language is just the tip of the iceberg. History \u00b6 The Wikipedia article is very good. But this is what you need to know: Python was created by a Dutch programmer named Guido van Rossum . Python is an old language . Yes, I know it looks (and feels) modern, but it's been around for quite some time. Python's first public distribution was in February 1991. (Original Python logo from the 90s/early 2000s) Guido designed Python while he was working at the CWI research center in the Netherlands. Python was inspired by another language called ABC , that was also being developed at CWI. A clear result of the influence of ABC on Python is its usage of indentation, that Guido himself explains in this post: http://python-history.blogspot.com/2011/07/karin-dewar-indentation-and-colon.html There's more to read about the history of Python. Guido has a few blogs in which he posts stubs from time to time: http://python-history.blogspot.com/ Python versions \u00b6 As mentioned in the previous section, Python is an old language. Today's most popular uses of Python are Web Development and Data Science , which not even remotely exist at the moment Python was created, back in the 90s. Python has obviously evolved to accommodate to today's needs, and with that evolution came different versions. Realistically, you only need to know that there are (were?) two major versions: Python 2 and Python 3 . Python 2 was the standard version when Python became \"popular\", I particularly started with Python 2.6 (back in 2008). Python 2 was a major redesign of Python itself (what used to be Python 1). I don't know many people that used Python 1, so Python 2 was basically the standard. Most of the features we are used to in Python were added in Python 2. But Python 2 was released in the year 2000, the standard CPU was the Pentium III. You can also guess that many of the decisions made at the time didn't adapt quite well to the modern world. Tip Python 2 is deprecated and Python 3 is the version you should be using. More about this in the installation and setup section. So Python 3 was born. It was actually conceived as Python 3000 or Py3K (I'm not kidding you, terrible names). The discussions about Python 3 started in the year 2006 with PEP 3000 (I'll explain what PEPs are later). Python 3 was again a major redesign of the language, and more importantly, it was NOT backwards compatible with Python 2 , which didn't appeal to too many people. Many important changes were introduced in Python 3, like default unicode support ( PEP 3120 ), print as a function, and others. Python 3 was developed in parallel with Python 2's regular feature improvements, bugfixes and security patches. The core Python team knew Python 3 was the future and the better option, but it took time for the community to embrace it. The result was that for a few years (between 2012-2018 I'd say), there were two incompatible languages being developed at the same time and it was chaotic. Library writers had to employ different tricks to make their packages compatible with both Py2 and Py3, and the community was divided. With time, everybody understood that Python 3 was superior, and adoption increased rapidly. Python 2 was deprecated on January 1st, 2020 . Python 3 is the only supported version . Features of the language \u00b6 Python supports all modern paradigms: imperative, Object Oriented (with multiple inheritance) and functional (although it's not purely functional). Python is interpreted , which means that, most of the time, your programs will work across multiple platforms. Python is dynamically typed , and has an acceptable type system. Python is also considered \"strongly typed\" , which is hard to define, but basically means you won't have strange behaviors like the ones in JavaScript or PHP ( \"10\" + 10 results in an error, for example). There are very few implicit type conversions done by the interpreter. In Python, everything is an object and, unlike Java, this is correctly (and consistently) implemented. The advantage is that, as every value is an object, we'll be able to overwrite methods, which will provide good extensibility. The \"everything is an object\" feature does increase memory footprint, as for example, what is a single int in any other language, ends up being a full object in Python's interpreter. Functions in Python are \"first class objects\" (everything is an object after all) and that empowers that \"functional\" flavor in Python: >>> map ( lambda x : x ** 2 , [ 1 , 2 , 3 , 4 ] >>> [ 1 , 4 , 9 , 16 ] Functional programming in Python is not pure. It's easy to introduce side effects and most collections are mutable. It feels more like a \"style\", than an enforced paradigm. In latter chapters we'll see a few features, like Haskell inspired List Comprehensions, that feel more \"functional\". Related to OOP, there are two important concepts that I want to point out and might be worth taking a look right now: Duck Typing and Mixins. Skip to the OOP chapter to read more about them. Garbage Collection \u00b6 Python's GC works by reference counting . The interpreter keeps a count of how many references exist to an object and, when that count reaches 0, the memory used by that object is freed. This is an example: # memory allocated for object with val 1 x = MyObject ( val = 1 ) # memory allocated for object with val 3 x = MyObject ( val = 3 ) # at this point, the interpreter knows that there are # no more references to the object with value 1, # and it can free up the memory Reference counting has advantages and disadvantages. To start with the good side, the main advantage of reference counting is its simplicity. At the beginning of the history of Python, when contributions were greatly needed, many programmers were able to start contributing to Python because of the simplicity of its interpreter. People attribute the popularization of Python to how simple it was to modify the interpreter and create C extensions. The disadvantages are twofold. First, reference counting is a GC algorithm considered \"naive\" and it can result in memory leaks or reference cycles more often than other more advanced (and modern) methods like \"reference graphs\" or tracing. And secondly, these reference counts are maintained in shared memory space within the process, which can be accessed and modified by any running thread. This could potentially result in race conditions, something that was resolved by the introduction of the Python GIL, a global interpreter lock that basically prevents multiple threads to run at the same time. Yes, you read correctly, in Python, threads can't run in parallel. More about this in the Concurrency chapter. Type Hints \u00b6 Starting with Python 3.5, there's support for \"Type Hints\", which might look like static typing, but it is NOT. Type hints are just a visual clue for programmers, editors and some other tools. Here's an example: def greeting ( name : str ) -> str : return 'Hello ' + name If you're interested in learning more about Type Hints, check out the mypy project, which implements \"optional static typing\". Python, the language \u00b6 This is the fine print: \"Python\" is just a specification, it's not an interpreter or a set of tools. It's just the specification of how the language should work, and interpreters must implement that. Think about it like XML: it's just a specification. There are libraries built on top of that spec that will let you parse XML documents. This is confusing because generally we refer as Python to CPython , the most widely used interpreter. When someone tells you \"download Python\", they're actually telling you to download the CPython interpreter, what in python.org is referred to as the \"traditional interpreter\". But as we'll see in the next section, there are several interpreters implementing Python , the language. Some folks have taken the idea of the \"specification\" and extended it, the most notable example is RPython (or restrictive Python) , which is a spec for a subset of Python that another interpreter uses (PyPy). Python interpreters \u00b6 CPython is the most widely used interpreter. It's what you get if you go to python.org and \"Download Python\". But remember, it's just 1 \"implementation\" of Python, the language specification . The other interpreter worth mentioning is PyPy . PyPy is a lot faster than CPython, it doesn't suffer from the problem of the GIL and it has a Just in Time compiler. PyPy is based on RPython, which means that there are restrictions to the code you can write (specially dynamic features like defining classes within functions, etc), but the main issue with PyPy is that the support for CPython C extensions is limited. It might be worth mentioning now that it's possible to write extensions for Python in C. This allows for improved performance and accessing other C libraries and function calls. A good example is the PostgreSQL library psycopg2 . C extensions are everywhere in the Python ecosystem, and that's probably the major drawback for PyPy. There are other interpreters that you might want to check out, although they're less popular: * Jython : Python implemented using Java. Basically means writing Python and accessing the whole java library ecosystem. * Iron Python : Python on top of the .NET Framework. * Stackless Python * MicroPython : Python for microcontrollers. In this crossover of specifications, compilers, subsets and supersets of Python, there are some very interesting projects. For example: Cython , a superset/interpreter/new-language that simplifies writing C extensions, with optional static typing support. What does it mean to be Pythonic\u00ae? \u00b6 If you open a Python interpreter and type import this , you'll see the Zen of Python : Beautiful is better than ugly . Explicit is better than implicit . Simple is better than complex . Complex is better than complicated . Flat is better than nested . Sparse is better than dense . Readability counts . Special cases aren 't special enough to break the rules. Although practicality beats purity . Errors should never pass silently . Unless explicitly silenced . In the face of ambiguity , refuse the temptation to guess . There should be one -- and preferably only one -- obvious way to do it . Although that way may not be obvious at first unless you 're Dutch. Now is better than never . Although never is often better than * right * now . If the implementation is hard to explain , it 's a bad idea. If the implementation is easy to explain , it may be a good idea . Namespaces are one honking great idea -- let 's do more of those! The Zen of Python was written by Tim Peters (yes, the one from the Timsort algorithm ) to provide a few \"guidelines\" for Python programmers. Regardless of what you think about these guidelines (I particularly love them, and I think they're very good advice, specially \"Explicit > Implicit\" and namespaces), you can already see that Python is an opinionated language . It's not that Guido just wrote the language, the interpreter and let it be, but there's also a \"soft\" recommendation of how to write \"proper\" Python code. I don't think there's any \"official\" description of how to write Pythonic code. It's more like a tacit agreement between Pythoners: write concise and clear code, and think about maintainability. Favor immutability as much as possible, try to use all the features of the language, etc. I think an example will express the philosophy behind Pythonic code in a better way. Suppose you have a list of tuples and you want to transform them into a dictionary (a mapping, key->value type). The un-Pythonic version would be: list_of_tuples = [( \u2018 rose ', 32), (\u2018john' , 25 )] user_age = {} for i in range ( len ( list_of_tuples )): element = list_of_tuples [ i ] user_age [ element [ 0 ]] = element [ 1 ] This code has a few issues. First, stylistically speaking, we're manually indexing the list to get the element at the ith position. We're also manually indexing the tuple. This can all be improved with the use of iteration and tuple unpacking: list_of_tuples = [( \u2018 rose ', 32), (\u2018john' , 25 )] user_age = {} for name , age in list_of_tuples : user_age [ name ] = age Just by relying on these 2 features of the language we got code that is more concise and clear. We still have the issue of \"mutability\", which can be resolved with another feature of the language which is a dict comprehension : list_of_tuples = [( \u2018 rose ', 32), (\u2018john' , 25 )] user_age = { name : age for ( name , age ) in list_of_tuples } The final result is just 2 lines of code, expressive, declarative (and readable), and it's atomic. There's another advantage to writing Pythonic code, which is consistency among Python projects. It feels very good to join a new project, with a new set of coworkers, and everybody follows the same style. Code formatting \u00b6 I won't provide many details here because we'll see the specific tools in the tooling section, but I'll say that Python has resolved the issue of different formatting among projects. There's an \"official\" code formatter, black created and maintained by the PSF (see next section), which is the \"standard\" in Python. It's very opinionated, and nobody agrees with it 100% , but we prefer conciseness among Python codebases than individual whims about single quotes or double quotes. With black, there are no discussions that are common in other languages, like where to place the braces in Java. Python governance \u00b6 Each python project has its own community, board or governing institution. But what you should really care about is the PSF, the Python Software Foundation . This is the mission stated by the PSF: The mission of the Python Software Foundation is to promote, protect, and advance the Python programming language, and to support and facilitate the growth of the international community of Python programmers. The PSF is in charge of raising funds for the development of Python, maintaining the official websites, documentation and the main online package repository, PyPI (similar to npm in JavaScript) and organizing PyCon US, the main Python conference in the US (more about this in the following sections). Strictly speaking, the PSF is not in charge of the actual development of CPython or Python, but in reality the boundaries between the two are vague. Communities and conferences \u00b6 Python has a highly cohesive ecosystem. Every Pythoneer knows each other and the communities are generally very friendly. There's a a major conference happening every year in the USA, which is PyCon US. Each country then organizes its own PyCon (full list available here ). There are other \"local\" conferences, for example PyCascades . These conferences and meetups are organized by different \"Python user groups\" in particular cities or areas. For example, ChiPy in Chicago or BayPiggies in San Francisco. The fact that we have such a cohesive community is sometimes detrimental, as it's a very \"personalistic\" community. There are a few well recognized people that you'll see pushing all the major projects and approvals. But that is generally fine, the people involved is amazing. Politics and philosophy \u00b6 Nobody likes to talk about politics. But they exist, and if you want to get involved with Python, you better have an idea of how it all works. I've participated in many communities and understanding what's the collective view of the people involved helps you communicate with them. !! Note: This is MY view of Python's politics and philosophy, to which I subscribe. There is no substantial proof aside from my own experience. If you have a different opinion please open an issue and we can discuss it. Python, as much of the open source community, belongs to the left-wing of politics. In the US political spectrum, we could say that Python is Social Democratic . There's no recognition of \"classes\" or families: it doesn't matter if someone is rich or not, actually it doesn't even come up. There's a big sense of \"social justice\" too, the community tries to help less favored groups and support minorities. For example: there has been an amazing progress in the past decade to encourage women to join the community by providing safe environments for their development. PyLadies or DjangoGirls are good examples. Generally speaking and, as a summary, the Python community is very friendly and comforting. Feel free to reach out to any of the contact options (shown below) and get started. PEPs: Python Enhancement Proposals \u00b6 PEPs are documents created by the community to propose new features or changes to the Python language. Sometimes they're also used for \"communication\" purposes, and not a technical specification (for example PEP 20 - The Zen of Python ). They're similar to JSRs (Java Specification Requests) in Java. As a good example, see PEP 8 which is probably the most widely known PEP. It describes good formatting and styling for Python programs (also an example of non-technical enhancement of the language). Read more about PEPs and the process in PEP 1 . Python communities \u00b6 Aside from the conferences and user groups mentioned above, there are a few online alternatives: Python user mailing list: https://mail.python.org/mailman/listinfo/python-list Reddit community: https://reddit.com/r/Python Reddit Learn Python: https://reddit.com/r/learnpython Python Discord: https://discord.com/invite/python","title":"2. Meta"},{"location":"meta/#python-language-meta-guide","text":"Knowing a language is more than knowing how to write a for-loop or spawn a thread. A language has an associated community, governance and even a political view. The syntax of the language is just the tip of the iceberg.","title":"Python Language - Meta Guide"},{"location":"meta/#history","text":"The Wikipedia article is very good. But this is what you need to know: Python was created by a Dutch programmer named Guido van Rossum . Python is an old language . Yes, I know it looks (and feels) modern, but it's been around for quite some time. Python's first public distribution was in February 1991. (Original Python logo from the 90s/early 2000s) Guido designed Python while he was working at the CWI research center in the Netherlands. Python was inspired by another language called ABC , that was also being developed at CWI. A clear result of the influence of ABC on Python is its usage of indentation, that Guido himself explains in this post: http://python-history.blogspot.com/2011/07/karin-dewar-indentation-and-colon.html There's more to read about the history of Python. Guido has a few blogs in which he posts stubs from time to time: http://python-history.blogspot.com/","title":"History"},{"location":"meta/#python-versions","text":"As mentioned in the previous section, Python is an old language. Today's most popular uses of Python are Web Development and Data Science , which not even remotely exist at the moment Python was created, back in the 90s. Python has obviously evolved to accommodate to today's needs, and with that evolution came different versions. Realistically, you only need to know that there are (were?) two major versions: Python 2 and Python 3 . Python 2 was the standard version when Python became \"popular\", I particularly started with Python 2.6 (back in 2008). Python 2 was a major redesign of Python itself (what used to be Python 1). I don't know many people that used Python 1, so Python 2 was basically the standard. Most of the features we are used to in Python were added in Python 2. But Python 2 was released in the year 2000, the standard CPU was the Pentium III. You can also guess that many of the decisions made at the time didn't adapt quite well to the modern world. Tip Python 2 is deprecated and Python 3 is the version you should be using. More about this in the installation and setup section. So Python 3 was born. It was actually conceived as Python 3000 or Py3K (I'm not kidding you, terrible names). The discussions about Python 3 started in the year 2006 with PEP 3000 (I'll explain what PEPs are later). Python 3 was again a major redesign of the language, and more importantly, it was NOT backwards compatible with Python 2 , which didn't appeal to too many people. Many important changes were introduced in Python 3, like default unicode support ( PEP 3120 ), print as a function, and others. Python 3 was developed in parallel with Python 2's regular feature improvements, bugfixes and security patches. The core Python team knew Python 3 was the future and the better option, but it took time for the community to embrace it. The result was that for a few years (between 2012-2018 I'd say), there were two incompatible languages being developed at the same time and it was chaotic. Library writers had to employ different tricks to make their packages compatible with both Py2 and Py3, and the community was divided. With time, everybody understood that Python 3 was superior, and adoption increased rapidly. Python 2 was deprecated on January 1st, 2020 . Python 3 is the only supported version .","title":"Python versions"},{"location":"meta/#features-of-the-language","text":"Python supports all modern paradigms: imperative, Object Oriented (with multiple inheritance) and functional (although it's not purely functional). Python is interpreted , which means that, most of the time, your programs will work across multiple platforms. Python is dynamically typed , and has an acceptable type system. Python is also considered \"strongly typed\" , which is hard to define, but basically means you won't have strange behaviors like the ones in JavaScript or PHP ( \"10\" + 10 results in an error, for example). There are very few implicit type conversions done by the interpreter. In Python, everything is an object and, unlike Java, this is correctly (and consistently) implemented. The advantage is that, as every value is an object, we'll be able to overwrite methods, which will provide good extensibility. The \"everything is an object\" feature does increase memory footprint, as for example, what is a single int in any other language, ends up being a full object in Python's interpreter. Functions in Python are \"first class objects\" (everything is an object after all) and that empowers that \"functional\" flavor in Python: >>> map ( lambda x : x ** 2 , [ 1 , 2 , 3 , 4 ] >>> [ 1 , 4 , 9 , 16 ] Functional programming in Python is not pure. It's easy to introduce side effects and most collections are mutable. It feels more like a \"style\", than an enforced paradigm. In latter chapters we'll see a few features, like Haskell inspired List Comprehensions, that feel more \"functional\". Related to OOP, there are two important concepts that I want to point out and might be worth taking a look right now: Duck Typing and Mixins. Skip to the OOP chapter to read more about them.","title":"Features of the language"},{"location":"meta/#garbage-collection","text":"Python's GC works by reference counting . The interpreter keeps a count of how many references exist to an object and, when that count reaches 0, the memory used by that object is freed. This is an example: # memory allocated for object with val 1 x = MyObject ( val = 1 ) # memory allocated for object with val 3 x = MyObject ( val = 3 ) # at this point, the interpreter knows that there are # no more references to the object with value 1, # and it can free up the memory Reference counting has advantages and disadvantages. To start with the good side, the main advantage of reference counting is its simplicity. At the beginning of the history of Python, when contributions were greatly needed, many programmers were able to start contributing to Python because of the simplicity of its interpreter. People attribute the popularization of Python to how simple it was to modify the interpreter and create C extensions. The disadvantages are twofold. First, reference counting is a GC algorithm considered \"naive\" and it can result in memory leaks or reference cycles more often than other more advanced (and modern) methods like \"reference graphs\" or tracing. And secondly, these reference counts are maintained in shared memory space within the process, which can be accessed and modified by any running thread. This could potentially result in race conditions, something that was resolved by the introduction of the Python GIL, a global interpreter lock that basically prevents multiple threads to run at the same time. Yes, you read correctly, in Python, threads can't run in parallel. More about this in the Concurrency chapter.","title":"Garbage Collection"},{"location":"meta/#type-hints","text":"Starting with Python 3.5, there's support for \"Type Hints\", which might look like static typing, but it is NOT. Type hints are just a visual clue for programmers, editors and some other tools. Here's an example: def greeting ( name : str ) -> str : return 'Hello ' + name If you're interested in learning more about Type Hints, check out the mypy project, which implements \"optional static typing\".","title":"Type Hints"},{"location":"meta/#python-the-language","text":"This is the fine print: \"Python\" is just a specification, it's not an interpreter or a set of tools. It's just the specification of how the language should work, and interpreters must implement that. Think about it like XML: it's just a specification. There are libraries built on top of that spec that will let you parse XML documents. This is confusing because generally we refer as Python to CPython , the most widely used interpreter. When someone tells you \"download Python\", they're actually telling you to download the CPython interpreter, what in python.org is referred to as the \"traditional interpreter\". But as we'll see in the next section, there are several interpreters implementing Python , the language. Some folks have taken the idea of the \"specification\" and extended it, the most notable example is RPython (or restrictive Python) , which is a spec for a subset of Python that another interpreter uses (PyPy).","title":"Python, the language"},{"location":"meta/#python-interpreters","text":"CPython is the most widely used interpreter. It's what you get if you go to python.org and \"Download Python\". But remember, it's just 1 \"implementation\" of Python, the language specification . The other interpreter worth mentioning is PyPy . PyPy is a lot faster than CPython, it doesn't suffer from the problem of the GIL and it has a Just in Time compiler. PyPy is based on RPython, which means that there are restrictions to the code you can write (specially dynamic features like defining classes within functions, etc), but the main issue with PyPy is that the support for CPython C extensions is limited. It might be worth mentioning now that it's possible to write extensions for Python in C. This allows for improved performance and accessing other C libraries and function calls. A good example is the PostgreSQL library psycopg2 . C extensions are everywhere in the Python ecosystem, and that's probably the major drawback for PyPy. There are other interpreters that you might want to check out, although they're less popular: * Jython : Python implemented using Java. Basically means writing Python and accessing the whole java library ecosystem. * Iron Python : Python on top of the .NET Framework. * Stackless Python * MicroPython : Python for microcontrollers. In this crossover of specifications, compilers, subsets and supersets of Python, there are some very interesting projects. For example: Cython , a superset/interpreter/new-language that simplifies writing C extensions, with optional static typing support.","title":"Python interpreters"},{"location":"meta/#what-does-it-mean-to-be-pythonic","text":"If you open a Python interpreter and type import this , you'll see the Zen of Python : Beautiful is better than ugly . Explicit is better than implicit . Simple is better than complex . Complex is better than complicated . Flat is better than nested . Sparse is better than dense . Readability counts . Special cases aren 't special enough to break the rules. Although practicality beats purity . Errors should never pass silently . Unless explicitly silenced . In the face of ambiguity , refuse the temptation to guess . There should be one -- and preferably only one -- obvious way to do it . Although that way may not be obvious at first unless you 're Dutch. Now is better than never . Although never is often better than * right * now . If the implementation is hard to explain , it 's a bad idea. If the implementation is easy to explain , it may be a good idea . Namespaces are one honking great idea -- let 's do more of those! The Zen of Python was written by Tim Peters (yes, the one from the Timsort algorithm ) to provide a few \"guidelines\" for Python programmers. Regardless of what you think about these guidelines (I particularly love them, and I think they're very good advice, specially \"Explicit > Implicit\" and namespaces), you can already see that Python is an opinionated language . It's not that Guido just wrote the language, the interpreter and let it be, but there's also a \"soft\" recommendation of how to write \"proper\" Python code. I don't think there's any \"official\" description of how to write Pythonic code. It's more like a tacit agreement between Pythoners: write concise and clear code, and think about maintainability. Favor immutability as much as possible, try to use all the features of the language, etc. I think an example will express the philosophy behind Pythonic code in a better way. Suppose you have a list of tuples and you want to transform them into a dictionary (a mapping, key->value type). The un-Pythonic version would be: list_of_tuples = [( \u2018 rose ', 32), (\u2018john' , 25 )] user_age = {} for i in range ( len ( list_of_tuples )): element = list_of_tuples [ i ] user_age [ element [ 0 ]] = element [ 1 ] This code has a few issues. First, stylistically speaking, we're manually indexing the list to get the element at the ith position. We're also manually indexing the tuple. This can all be improved with the use of iteration and tuple unpacking: list_of_tuples = [( \u2018 rose ', 32), (\u2018john' , 25 )] user_age = {} for name , age in list_of_tuples : user_age [ name ] = age Just by relying on these 2 features of the language we got code that is more concise and clear. We still have the issue of \"mutability\", which can be resolved with another feature of the language which is a dict comprehension : list_of_tuples = [( \u2018 rose ', 32), (\u2018john' , 25 )] user_age = { name : age for ( name , age ) in list_of_tuples } The final result is just 2 lines of code, expressive, declarative (and readable), and it's atomic. There's another advantage to writing Pythonic code, which is consistency among Python projects. It feels very good to join a new project, with a new set of coworkers, and everybody follows the same style.","title":"What does it mean to be Pythonic\u00ae?"},{"location":"meta/#code-formatting","text":"I won't provide many details here because we'll see the specific tools in the tooling section, but I'll say that Python has resolved the issue of different formatting among projects. There's an \"official\" code formatter, black created and maintained by the PSF (see next section), which is the \"standard\" in Python. It's very opinionated, and nobody agrees with it 100% , but we prefer conciseness among Python codebases than individual whims about single quotes or double quotes. With black, there are no discussions that are common in other languages, like where to place the braces in Java.","title":"Code formatting"},{"location":"meta/#python-governance","text":"Each python project has its own community, board or governing institution. But what you should really care about is the PSF, the Python Software Foundation . This is the mission stated by the PSF: The mission of the Python Software Foundation is to promote, protect, and advance the Python programming language, and to support and facilitate the growth of the international community of Python programmers. The PSF is in charge of raising funds for the development of Python, maintaining the official websites, documentation and the main online package repository, PyPI (similar to npm in JavaScript) and organizing PyCon US, the main Python conference in the US (more about this in the following sections). Strictly speaking, the PSF is not in charge of the actual development of CPython or Python, but in reality the boundaries between the two are vague.","title":"Python governance"},{"location":"meta/#communities-and-conferences","text":"Python has a highly cohesive ecosystem. Every Pythoneer knows each other and the communities are generally very friendly. There's a a major conference happening every year in the USA, which is PyCon US. Each country then organizes its own PyCon (full list available here ). There are other \"local\" conferences, for example PyCascades . These conferences and meetups are organized by different \"Python user groups\" in particular cities or areas. For example, ChiPy in Chicago or BayPiggies in San Francisco. The fact that we have such a cohesive community is sometimes detrimental, as it's a very \"personalistic\" community. There are a few well recognized people that you'll see pushing all the major projects and approvals. But that is generally fine, the people involved is amazing.","title":"Communities and conferences"},{"location":"meta/#politics-and-philosophy","text":"Nobody likes to talk about politics. But they exist, and if you want to get involved with Python, you better have an idea of how it all works. I've participated in many communities and understanding what's the collective view of the people involved helps you communicate with them. !! Note: This is MY view of Python's politics and philosophy, to which I subscribe. There is no substantial proof aside from my own experience. If you have a different opinion please open an issue and we can discuss it. Python, as much of the open source community, belongs to the left-wing of politics. In the US political spectrum, we could say that Python is Social Democratic . There's no recognition of \"classes\" or families: it doesn't matter if someone is rich or not, actually it doesn't even come up. There's a big sense of \"social justice\" too, the community tries to help less favored groups and support minorities. For example: there has been an amazing progress in the past decade to encourage women to join the community by providing safe environments for their development. PyLadies or DjangoGirls are good examples. Generally speaking and, as a summary, the Python community is very friendly and comforting. Feel free to reach out to any of the contact options (shown below) and get started.","title":"Politics and philosophy"},{"location":"meta/#peps-python-enhancement-proposals","text":"PEPs are documents created by the community to propose new features or changes to the Python language. Sometimes they're also used for \"communication\" purposes, and not a technical specification (for example PEP 20 - The Zen of Python ). They're similar to JSRs (Java Specification Requests) in Java. As a good example, see PEP 8 which is probably the most widely known PEP. It describes good formatting and styling for Python programs (also an example of non-technical enhancement of the language). Read more about PEPs and the process in PEP 1 .","title":"PEPs: Python Enhancement Proposals"},{"location":"meta/#python-communities","text":"Aside from the conferences and user groups mentioned above, there are a few online alternatives: Python user mailing list: https://mail.python.org/mailman/listinfo/python-list Reddit community: https://reddit.com/r/Python Reddit Learn Python: https://reddit.com/r/learnpython Python Discord: https://discord.com/invite/python","title":"Python communities"},{"location":"strings/","text":"Formatting __str__ , __repr__ Unicode, bytes","title":"Strings"}]}